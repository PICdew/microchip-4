// 
// C:\_projects\microchip\PIC16F1719\bbgame.X\test-stim-file.scl
// Generated by Stimulus MPLAB X
// Fri Jan 01 19:48:01 MST 2016
// 


configuration for "pic16f1719" is
    shared variable PORTCbits;
end configuration;

testbench for "pic16f1719" is
begin
    COND1: process is
    begin
        wait until RC2 == '1';
        RC0 <= '0';
        wait for 1 ic;
    end process COND1;

    // Register Injection (message-based)
    barf: process is
        file     data_file_PORTCbits  : text;
        variable pkt_line_PORTCbits   : line;
        variable status_PORTCbits     : file_open_status;
        variable read_ok_PORTCbits    : boolean;
        variable waitime_PORTCbits  : time;
        variable rand_lower_PORTCbits,
                 rand_upper_PORTCbits : integer;
        variable rand_unit_PORTCbits  : string;
        variable randime_PORTCbits  : time;
        variable rand_seed1_PORTCbits : integer := 21754;
        variable rand_seed2_PORTCbits : integer := 1017;
        variable packet_PORTCbits     : string;
        variable dummy_PORTCbits      : integer;
        variable new_packet_PORTCbits : boolean := true;
    begin
        file_open(status_PORTCbits, data_file_PORTCbits, "", read_mode);
        if status_PORTCbits == open_ok then
            while endfile(data_file_PORTCbits) == false loop
                readline(data_file_PORTCbits, pkt_line_PORTCbits);
                // skip empty line and comment line
                if match(pkt_line_PORTCbits, "") == true then // do nothing
                elsif match(pkt_line_PORTCbits, "//") == true then // do nothing
                else
                    if match(pkt_line_PORTCbits, "wait ") == true then
                        read(pkt_line_PORTCbits, dummy_PORTCbits); // to consume 'wait' command
                        read(pkt_line_PORTCbits, waitime_PORTCbits);
                        wait for waitime_PORTCbits;
                        new_packet_PORTCbits := true;
                    elsif match(pkt_line_PORTCbits, "rand ") == true then
                        read(pkt_line_PORTCbits, dummy_PORTCbits); // to consume 'rand' command
                        read(pkt_line_PORTCbits, rand_lower_PORTCbits);
                        read(pkt_line_PORTCbits, rand_upper_PORTCbits);
                        read(pkt_line_PORTCbits, rand_unit_PORTCbits);
                        random_time(rand_lower_PORTCbits, rand_upper_PORTCbits, rand_unit_PORTCbits,
                                    rand_seed1_PORTCbits, rand_seed2_PORTCbits, randime_PORTCbits);
                        wait for randime_PORTCbits;
                        new_packet_PORTCbits := true;
                    else
                        if new_packet_PORTCbits == true then
                            packetin(pkt_line_PORTCbits, PORTCbits, false); // new packet
                            wait until PORTCbits_packet_done;
                            new_packet_PORTCbits := false;
                        else
                            packetin(pkt_line_PORTCbits, PORTCbits, true); // append to previous
                            wait until PORTCbits_packet_done;
                        end if;
                    end if;
                end if;
            end loop;
        else
            file_close(data_file_PORTCbits);
            wait;
        end if;
        file_close(data_file_PORTCbits);
    end process barf;

end testbench;
